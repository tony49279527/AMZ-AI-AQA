# 数据来源展示与持久化方案

> 目标：1）在生成报告的同时，有地方**展示「用到了哪些数据」**（链接、条数、字符数）；2）把**抓取到的全部原始资料存进数据库**，供后续**问答系统**不仅基于报告正文，还能基于这些资料作答。

---

## 一、要满足的两点

1. **可追溯、可展示**
   - 例如：抓了 10 个 YouTube，要能看到这 10 个的**链接**；
   - 抓了 20 个产品相关网站，要能看到这 20 个的**链接**；
   - 每个维度要能看到**抓了多少内容**（大概多少字符）。
2. **持久化到数据库**
   - 抓到的内容（产品信息、评论、网站正文、YouTube 字幕、退货报告、人群画像）都要入库；
   - 原因：**问答系统**不仅要「答报告本身」，还要能「答背后已抓取的所有资料」，所以需要能按 report 查询这些原始数据并参与检索/上下文。

---

## 二、数据模型设计

### 2.1 用「数据库」存抓取结果

当前报告是：报告正文在 `report_<id>.md`，元数据在 `report_<id>.meta.json`，没有数据库。要支持问答用「抓取资料」，且你说要存数据库，建议：

- **新增一个数据库**（推荐先用 **SQLite**，单文件、零运维，后续可迁 PostgreSQL）。
- **一张表：报告抓取来源**，按「每条来源」存一条记录，便于按报告查、按类型筛、并参与问答检索。

### 2.2 表结构建议：`report_sources`

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | 主键 | 自增或 UUID |
| `report_id` | 文本 | 报告 ID，与现有 report_<id> 一致 |
| `source_type` | 文本 | 枚举：`product_info` / `reviews` / `reference_site` / `reference_youtube` / `return_report` / `persona` |
| `source_key` | 文本 | 唯一标识这条来源：网站/视频用 **URL**；产品/评论用 **ASIN**（可带后缀区分主品/竞品）；退货/人群用固定值如 `file` |
| `display_label` | 文本（可选） | 展示用：如域名、视频标题、ASIN 等 |
| `content` | 长文本 | **完整抓取内容**，供问答检索与展示 |
| `char_count` | 整数 | 内容字符数，用于展示「抓了多少」 |
| `meta` | JSON（可选） | 扩展信息：如 page、rating、fetch_time 等 |
| `created_at` | 时间 | 入库时间 |

**示例**：

- 参考网站：`source_type=reference_site`，`source_key=https://...`，`display_label=reddit.com`，`content=网页正文`，`char_count=5000`
- 参考 YouTube：`source_type=reference_youtube`，`source_key=https://youtube.com/watch?v=xxx`，`display_label=视频标题`，`content=字幕全文`，`char_count=3000`
- 产品信息：可按 ASIN 存多条，或一条汇总；`source_key=ASIN`，`content=该 ASIN 产品详情文本`
- 评论：可按 ASIN 存一条（该 ASIN 所有评论合并），`source_key=ASIN`，`content=评论合并文本`
- 退货报告：`source_type=return_report`，`source_key=file`，一条，无则无记录
- 人群画像：`source_type=persona`，`source_key=file`，一条

这样：

- **展示「用到了什么」**：按 `report_id` 查 `report_sources`，**只返回** `source_type`、`source_key`（作链接）、`display_label`、`char_count`，**不返回** `content`。前端「数据源」Tab 一行一条列出即可，不做全文展示。
- **问答**：按 `report_id` 查所有 `report_sources`，把 `content` 和报告正文一起做检索/拼上下文，模型即可「基于报告 + 抓取资料」回答。

### 2.3 报告元数据（现有）的扩展

现有 `report_<id>.meta.json` 里的 `dataFiles` 是「展示用清单」（名称、分类等），没有 URL 和字数。可以：

- **方案 A**：继续用 metadata 的 `dataFiles` 只做简要展示；**真实链接与字数**从数据库 `report_sources` 查出来，在「数据源」Tab 用新 API 返回。
- **方案 B**：生成报告时，除了写 DB，同时把「来源摘要」（类型、数量、总字符数、链接列表）写回 metadata 的某个字段（如 `sourcesSummary`），这样列表/详情不依赖 DB 也能显示概览；详情页「数据源」Tab 仍从 DB 取完整列表+链接。

推荐 **方案 B**：metadata 里有一份摘要（便于列表/概览），完整明细和正文从 DB 读（便于展示链接+字数、以及问答）。

---

## 三、报告生成流程的改动（写入 DB）

在现有「拉数据 → 拼提示词 → 调 LLM → 写 report_<id>.md」的流程里，增加「**每抓到一块就写入 report_sources**」：

1. **分配 report_id** 后立刻可以写库（同一请求内）。
2. **产品信息**：按 ASIN 拉取，每个 ASIN 一条 `product_info` 记录，`source_key=asin`，`content=该 ASIN 产品详情文本`，`char_count=length`。
3. **评论**：按 ASIN 拉取（每 ASIN 最多 100 条），每个 ASIN 一条 `reviews` 记录，`source_key=asin`，`content=该 ASIN 评论合并文本`，`char_count=length`。
4. **参考网站**：每抓一个 URL 一条 `reference_site` 记录，`source_key=url`，`display_label=域名或标题`，`content=抓到的正文`，`char_count=length`。
5. **参考 YouTube**：每个视频一条 `reference_youtube` 记录，`source_key=视频 URL`，`content=字幕文本`，`char_count=length`。
6. **退货报告**：有则一条 `return_report`，`source_key=file`，`content=解析后的全文`，`char_count=length`。
7. **人群画像**：有则一条 `persona`，同上。

这样，**生成报告的同时**，数据库里已经有「这份报告用到的全部来源 + 完整内容」，方便后面展示和问答。

---

## 四、展示「用到了哪些数据」——只做总览，不展示正文

### 4.1 展示位置与原则

- **位置**：报告详情页已有的 **「数据源」Tab**（`value="sources"`）。
- **原则**：
  - **只做总览**：一行一行列出来「我们用了什么数据」即可，让用户知道本报告用到了哪些数据源。
  - **不展示大量正文**：渠道抓到的文档本身（网页正文、字幕、评论全文等）**只存在数据库里**，供系统（如问答）使用；**不在数据源 Tab 里展示**，不展开原文、不展示大段字符，避免界面复杂、体积过大。

### 4.2 建议展示形式：一行一条的列表

每一行只说明「这是什么」：类型 + 简要标识（链接/ASIN/文件名）+ 可选「约 X 字」。

| 类型 | 每一行示例（用户看到的） |
|------|--------------------------|
| 参考网站 | 参考网站 · reddit.com · 约 5,200 字（链接可点击） |
| 参考网站 | 参考网站 · garagejournal.com · 约 3,100 字 |
| 参考 YouTube | 参考 YouTube · 某视频标题或链接 · 约 2,800 字 |
| 产品信息 | 产品信息 · ASIN B0XXX · 约 1,500 字 |
| 产品评论 | 产品评论 · ASIN B0XXX · 约 8,200 字 |
| 退货报告 | 退货报告 · 用户上传 · 约 4,100 字 |
| 人群画像 | 人群画像 · 用户上传 · 约 2,900 字 |

- **不提供**「展开原文」「查看全文」：正文只在库中，供问答等能力使用。
- 数据来源：**新 API** `GET /api/reports/:reportId/sources`，返回**列表摘要**（每条：`source_type`、`display_label` 或链接、`char_count`），**不**返回 `content` 字段。前端在「数据源」Tab 按行渲染即可。

---

## 五、问答系统如何使用这些资料

当前问答：只读 `report_<id>.md`，按章节切分，再按用户问题做关键词排序，取若干章节拼成上下文。

改造思路：

- **同一 report_id** 下，除报告正文外，再从 `report_sources` 查出该报告的所有 `content`（可按类型过滤，如只取 reference_site + reference_youtube + reviews，避免单次上下文过长）。
- **检索策略**：  
  - 简单版：报告章节 + 所有来源各做「关键词/向量」排序，取 Top-K 片段拼成上下文；  
  - 或：报告用现有章节检索，来源用同一套关键词/向量检索，两者合并去重后作为「报告+抓取资料」上下文。
- 在 system 或 user 里说明：回答可基于「报告内容」与「以下抓取资料（网站、视频字幕、评论等）」；引用时标注来源（如 [来源: 报告 第X章]、[来源: 参考网站 reddit.com]、[来源: 评论 ASIN xxx]）。

这样，**抓到的内容都已在数据库**，问答接口按 report_id 查库即可，无需再实时抓取。

---

## 六、技术选型与实现顺序

### 6.1 数据库

- **首选 SQLite**：单文件、无需单独服务，适合先跑通；表只需 `report_sources`（若要把 report 元数据也迁进库可再加 `reports` 表，非必须）。
- 接入方式：**better-sqlite3**（同步、轻量）或 **Prisma**（带迁移、类型安全）。若你已有 PostgreSQL，可改为 PG，表结构一致。

### 6.2 实现顺序建议

1. **建库 + 表**  
   - 创建 SQLite DB（如 `content/data/report_sources.db` 或项目根下），建表 `report_sources`。
2. **报告生成时写库**  
   - 在 generate 流程里，每拿到一块数据（产品、评论、网站、YouTube、退货、人群）就插入 `report_sources`；若某块失败可只记日志，不阻塞报告生成，该块在「数据源」里显示为 0 条。
3. **新 API：GET /api/reports/:reportId/sources**  
   - 查 `report_sources`，按 `source_type` 分组，返回列表（含链接、字符数、可选 content 摘要）。
4. **报告详情页「数据源」Tab**  
   - 调用上述 API，展示「用了哪些网站/视频/ASIN、各多少字符」。
5. **问答接口改造**  
   - 加载报告正文的同时，按 report_id 查 `report_sources`，把 `content` 纳入检索/上下文，并在提示词中说明可引用这些来源。

### 6.3 与现有「阶段一」的衔接

- 阶段一仍可先做：FormData、文件解析、评论注入、按模板单次生成报告。
- 在**同一次生成**里增加：  
  - 拉到的每一条数据在拼提示词的同时，**插入 report_sources**；  
  - 生成完成后可写 metadata 的 `sourcesSummary`（可选）。  
这样从第一版开始就有「可展示 + 可问答」的抓取数据，无需后面再补跑。

---

## 七、小结

| 需求 | 做法 |
|------|------|
| 确保/展示「抓到了想要的产品相关数据」 | 在报告详情页「数据源」Tab 展示：参考网站/YouTube 的**链接列表** + 各类型**条数**与**总字符数**；数据来自 DB 的 `report_sources`。 |
| 抓取内容要存数据库 | 新增 SQLite 表 `report_sources`，报告生成时每抓一块写一条，含 `content` 与 `char_count`。 |
| 问答要能答「背后抓取的所有资料」 | 问答接口按 `report_id` 查 `report_sources`，把 `content` 与报告正文一起做检索并拼入上下文，并注明可引用这些来源。 |

按上述顺序实现后，你就同时具备「展示用到了哪些数据」和「把这些资料持久化供问答使用」的能力。若你确认用 SQLite 和这张表结构，我可以再按你当前代码结构给出具体的建表 SQL、插入时机（在 generate 的哪几步调）、以及 `GET /api/reports/:reportId/sources` 的返回格式示例，方便直接落地。
